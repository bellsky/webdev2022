20220926_study


금일 강의 정보보안, 컴퓨터일반, 프로그래밍언어

정보보안 20220926

    3장 공개 키 암호와 메시지 인증

    3.1 메시지 인증 방법.

    암호 사용 시 passive 공격(도청 등) 방어 가능, 그러나 active는 다른 방법이 필요하다.
    소스(근원지) 인증과 메시지(본문) 인증, 메시지 인증에는 이 두가지 요소가 필요하다.

    관용 암호를 이용한 인증
        -송신자 수신자 둘이 동일한 키를 가지고 있다고 가정
        -오직 진짜 송신자만이 수신자에게 보내는 메시지를 성공적 암호화 가능.
        -메시지 변경 탐지
            -오류 감지 코드 및 순서 번호 존재 시 변경 여부와 순서 확인 가능.
            -타임스태프 : 딜레이(지연) 없는 전달 확인.
        -대칭암호만 가지고서는 데이터 인증에 부적합하다.
            -ECB 모드의 암호화에서는 공격자가 암호문의 블록을 뒤섞으면 내용도 뒤바뀐다.


    메시지 암호화 없이 메시지 인증
        -암호에 의존하지 않고 메시지 인증 방법
            -암호화 안하고 인증 꼬리표tag 붙여 보내기.
            -대신 기밀성은 보장하지 않는다.

    메시지 암호 없는 메시지 인증이 적합할 때
        -브로드 캐스팅 : 네트워크경고
        -메시지 복호화 시간이 부족할 때(ex:테스팅)
        -컴퓨터 프로그램은 평문인 채로 인증하는 게 더 편리하다.


    메시지 인증 코드 MAC
        :메시지에 붙여지는 작은 데이터 블록을 생성하기 위해 비밀키를 이용하는 방법.

    MAC 계산법 : p.76

    MAC 효과 :
        -수신자는 메시지가 변경되지 않았다고 확신.
        -수신자는 송신자가 소스임을 확신.
        -메시지 순서번호를 사용 시 순서도 확신.

        여러 알고리즘이 사용가능하나, NIST 규격 뭐시기에서는 DES사용을 권장한다.
        암호화된 메시지의 끝단 일부분MAC만을 비교 대상으로 사용한다?
        암호화와 다른 점은, 인증 알고리즘으로는 복호화에서의 역산이 불가능하다는 것이다.


    일방향 해시 함수
        : 메시지 인증 코드처럼 임의 크기의 메시지M을 받아들여 일정한 크기의 메시지 다이제스트 H(M)을 출력하는 함수.

        -해시 = H(M)
            -H : 해시함수, M=메시지

    일방향 해시 함수를 이용한 메시지 인증 방법
        -관용 암호 사용 방법
        -공개키 암호 사용 방법
        -비밀 값 사용 방법







컴퓨터일반 0926

    구글에서 뭘 할 수 있을까 
    도 숙제

    '여러분들 다 연계전공 등록되어 있는 거에요
    이 거(강의)듣고 있기 때문에' -> 본인은 비해당됨.

    스칼라 = 순간적인 힘의 양 그 자체.
    벡터 = 거기에 방향까지 포함한 개념

    CH.4 소프트웨어와 운영체제

    4-1. 소프트웨어의 이해.
        소프트웨어란? 컴퓨터 내의 일 처리 순서와 방법을 지시하는 명령어의 집합인 프로그램과 수행에필요한 절차, 규칙, 관련 문서를 총칭하는 용어.

        소프트웨어의 분류 
            시스템/응용 소프트웨어
            펌웨어/미들 웨어  펌웨어 : 하드웨러를 제어하는 작은 규모의 소프트웨어.
            미들웨어 : 시스템/응용 간 혹은 이종 프로그램 간 중개 역할을 하는 프로그램이다.

        1.소프트웨어의 개념

        구매 방법에 의한 분류
            -상용 sw : 개발자가 목적을 가지고 상품으로 출시
            -주문형 sw : 특정 개인 혹은 집단의 목적으로 타 개발자/업체에게 맡겨 개발함.
            -셰어웨어 : 시힘 사용 기간을 제공하는 샘플 프로그램.
            -프리웨어 : 영리목적 불가능으로 라이센스 요금 없이 무료 배포
            -오픈소스 s/w : 소스코드까지 제공되어 유저가 자유롭게 수정 변경할 수 있는 소프트웨어.


        1.시스템 소프트웨어란
            :컴퓨터를 관리하기 위한 sw. 컴퓨터 사용에 반드시 필요.
            보통 운영체제 + 시스템 관리 유틸을 합쳐서 부른다. 하드웨어와 응용 소프트웨어를 연결해준다.-시스템 소프트웨어의 종류
            --운영체제 : 하드웨어와 소프트웨어 자원을 효과적으로 관리하고 운영하기 위한 소프트웨어.
            --언어처리기 = 컴파일러(*고급언어->기계언어), 어셈블러, 링커, 로더 등.
            --라이브러리 : 프로그램의 일부를 이후에도 활용할 수 있도록 조직적으로 구성해놓은 소프트웨어.
            --장치 드라이버 : 장치 제어용.
            --유틸리티 : 사용자가 컴퓨터를 더 효과적으로 쓰기 위한 소프트웨어.


        3. 응용 소프트웨어
            : 특정 분야에서 쓰기 위해 제작한 소프트웨어..
            -응용 소프트웨어의 종류
            --사무용 : 한글 엑셀 등.
            -그래픽 : 포토샵 등
            -설계 및 생산 자동화 : 오토캐드
            -멀티미디어용 : 곰플레이어 등
            -게임 소프트웨어


        4. 소프트웨어 공학(엔지니어링)
            : SW 개발 계획부터 운용, 유지 보수, 폐기까지의 전 과정에 필요한 이론과 기술을 다루는 학문.
            소프트웨어의 크기가 작았을 때는 제작 수정에 드는 부담이 적었으나 크기가 커지면서 이를 효과적으로 관리하기 위한 개발 방법론이 필요해졌다.

            -소프트웨어 개발 주기 : 소프트웨어를 개발하는 시점부터 사용이 완전히 끝나 폐기될 때까지의 전과정을 단계별로 나눈 것.
            -단계 : 요구분석 – 설계 – 구현 – 테스트 - 유지보수

            --점진적모델 : 간단한 시스템부터 개발 이후 목표에 맞춰 나머지 부분 개발
            --프로토타입 모델 : 사용자의 요구를 파악하기 위해 프로토타입을 만든다. 요구 분석 단계에서 주로 쓰인다.
            --애자일 개발방법론 : 무계획과 과계획 사이의 타협점.



    4-2. 운영체제의 개요

        1. 운영체제의 개념
            : 하드웨어 장치를 관리하고 사용자의 편리한 컴퓨팅 환경을 제공하고 응용 소프트웨어의 효율적인 실행을 지원하는 시스템 소프트웨어.

        2. 운영체제의 기능
        -자원관리
        --컴퓨터의 멀티태스킹 환경 보편화.
        --응용 프로그램의 우선순위를 정하는 것도 OS에서 함.

        -자원보호
        --악의적인, 혹은 미숙한 사용자로부터 보호받아야 한다.
        --프로그램의 실행 오류 혹은 설계 오류로 인해 자원의 오사용되는 경우를 감시하여 컴퓨터의 자원을 지키는 역할을 수행.


    3. 운영체제의 종류

        -컴퓨터 운영체제

        --유닉스
        ---1969년 벨 연구소의 켄 톰슨이 개발.
        ---현재도 널리 쓰임.
        ---인터넷 서버 컴퓨터의 핵심.


        --리눅스
        ---1991년 리누스 토발즈가 개발, 유닉스 호환.
        ---소스코드를 공개하여 사용자가 자유롭게 이용(변용) 가능.
        ---다용 사용자, 다중 작업, 가상 터미널 환경 지원, 네트워크 운영체제 활용 가능.

        --윈도우
        ---ms가 개발, 개인용 컴퓨터 1위. 도스에서 꾸준히 업글됨.
        --맥os
        ---애플사의 매킨토시에 쓰일 목적으로 개발된 GUI 운영체제.
        ---강력한 기능을 제공하는 생산자 유리 소프트웨어

        -모바일 운영체제
        --안드로이드
        --ios


    4. 운영체제의 구성

        -커널
            :운영체제의 핵심. 사용자가 관여할 수 없는 시스템 레벨 수준의 제어 작업 수행.
            메모리 관리, 프로세스 관리, 입출력장치 관리 등.
            --UI 사용자 인터페이스
            ---CLI
            ---GUI


    5. 운영체제의 관리
        -초기 컴퓨터는 한번에 하나의 프로그램만 실행되는 단일 프로그래밍 시스템이었음.
        -요즘엔 다중 프로그래밍 시스템. -> 운영체제의 프로세스, 메모리 관리 기능이 중요해짐.
        -메모리 내 프로세스 위치를 추적하기 위해 메모리 관리, 프로세스 간 영역 침범하지 않게 프로세스 관리.


    4.3 운영체제의 프로세스 관리

        1. 프로세스의 개념
            : 실행 명령을 받아 메인 메모리로 올라간 프로그램.
            운영체제 운영되는 시스템 작업의 기본 단위이다.
            준비-실행
            -준비 : 생성된 프로세스가 cpu 사용 시간 할당을 받기 위해 대기중.
            -실행 
            --종료:모든 작업이 끝났을 때
            --중단/방해 : 프로세스의 cpu 할당시간 완료 혹은 방해(인터럽트)가 발생 시 준비상태로 되돌아간다.
            ---입출력 또는 이벤트 기다림 : 실행중인 프로세스가 입출력 명령을 마치면 남은 시간을 반환하고 다음 입출력 종료 신호가 올 때까지 대기 상태.


            -여러개의 프로세스가 동시에 실행되는 과정
            --준비 실행 대기 삼각관계

        2. 프로세스 제어 블록 PCB
            -문맥전환 : 다중 프로그래밍 환경에서 실행중인 프로세스의 정보(레지스터 값등)를 
            해당 프로세스의 PCB에 저장하고 새롭게 실행된 프로세스의 정보를 cpu에 적재하는 과정.

        3. 프로세스 스케쥴링
            : 다중 프로그래밍 환경에서 현재 실행중인 프로세스 다음에 어떤 프로세스를 실행할지 결정하는 과정.
            -프로세스 스케쥴링 기법 3가지
            --FCFS : 선입선출
            --SJF : 목록에서 cpu 사용 시간이 가장 짧은 프로세스부터 실행.
            --라운드로빈 : 여러 프로세스가 돌아가면서 cpu를 조금씩 사용함.

        4. 병행 프로세스
            :2개 이상의 프로세스가 동시에 실행되는 경우. 두 개가 영향을 주고받아 예측불가능한 상황이 발생하기도.
            -병행 처리에서의 오류를 막기 위해 쓰는 개념
            --동기화 : 하나의 자원에 2개 이상의 프로세스가 동시에 접근 시 처리순서를 지켜야함.
            --임계영역 : 병행 프로세스의 코드 영역에서 작업이 이루어지는 부분.
            --상호배제 : 하나의 프로세스가 공유 자원 사용 시 다른 프로세스가 자원을 사용하지 못하게 하는 것.

        5. 교착 상태=데드락
            : 두 개 이상의 프로세스가 절대 일어나지 않을 이벤트를 기다리고 있는 상태.
            특정 프로세서가 공유자원을 독점하여 사용중인데 다른 프로세스가 그 자원을 요구 시 발생.
            (ex 철학자들의 만찬 )

         -자원할당그래프 : 사각형 프로세스 원이 자원. 화살표는 요청과 할당을 의미


        -교착상태에 빠지는 조건
            --상호배제
            --보유와 대기
            --비선점
            --순환대기


        -교착상태 해결을 위한 운영체제의 방안
            --방지 : 위 4개 조건이 모두 해당되어야 교착상태에 빠지므로, 4개 중 1개 이상을 제거하여 방지하는 것.
            --회피 : 미리 가능성을 살펴서 가능성 없을 때만 자원을 할당.
            --탐지와 회복 : 교착상태 발생을 감지하고 해결
            --무시 : 교착 상태 발생해도 무시하는 것.


    4.4 운영체제의 메모리 관리

        1. 메인메모리 관리 1 : 단일 프로그래밍
            -단일프로그래밍 기법 : 운영체제 외의 사용자 프로세스 단 하나만 저장하는 방식. 
            주기억장치에 하나만 저장되고 실행된다.
            -운영체제가 끝난 부분을 메모리 시작 부분으로 두고 사용자 프로그램을 로드하면 
            침범하지 않게만 막으면 됨.
            -역할이 단순하여 구현은 쉽지만 cpu는 효율적으로 사용할 수 없다.

        1. 메인메모리 관리 2 : 다중 프로그래밍
            -다중 프로그래밍 기법 : 메인메모리에 여러개의 작업을 쌓아둔 뒤 
            cpu가 작업을 오가며 동시 실행.

            -고정 분할 메모리 관리
                --고정 분할 메모리 관리 기법 : 분할된 메모리 구조 유지하다가 프로그램 실행 시 적당한 위치 선정.
                --나눠진 공간 = 하나의 작업이 ᄊᆞᇂ일 수 있는 일정 크기의 기억 공간. 따라서 다른 프로세스가 침범하지 않도록 보호되어야 한다. 이를 위해 상한 주소와 하한 주소값을 가진 레지스터를 사용한다. 
                --단편화 : 작업량과 분할 공간의 크기가 불일치하여 빈공간이 생기는 것.
                --내부 단편화 : 분할 된 공간 내에 작업물이 들어가 있지만, 작업물보다 분할 공간이 더 커서 빈 공간이 생기는 것.
                --외부 단편화 : 분할 공간의 크기가 작업량 보다 작아서 빈 공간이 된 경우.

            -가변 분할 메모리 관리
                --:고정 분할 메모리 관리 기법의 단점 보완.
                --고정된 분할 공간의 경계를 없애어 작업량에 맞는 공간 할당, 작업 완료 시 빈공간은 다시 합쳐서 관리한다. (*실행중인 프로세스를 재배치하는 과정을 수행한다.)
                --사용자 프로그램 실행 시 그때그때 맞는 크기로 공간을 분할하여 할당하는 것.

                --빈 공간에 새로운 프로그램을 할당하는 방식 3가지.
                    ---최초적합 : 프로그램 크기보다 큰 분할 공간 중 처음 만나는 공간을 할당함.
                    ---최적적합 : 큰 것 중 가장 작은 공간을 할당함.
                    ---최악적합 : 가장 큰 공간을 할당함.

        3. 가상메모리 관리
            : 지금 당장 실행해야 하는 부분만 메인메모리에 저장하고 나머지 프로그램은 보조기억장치에 둔 채 동작하는 방법이다.
            -실행할 프로그램 크기가 메인메모리보다 크거나 개수가 많으면 메인메모리 내 공간이 부족하여 프로그램이 제대로 실행되지 못하는 문제를 해결함.
            -페이징 기법 : 프로그램을 일정 크기=페이지로 나누어 단위별로 메인 메모리에 올려 동작하는 방식.
            -요구 페이징 기법:
            -세그멘테이션 기법 : 가상메모리를 프로그램이나 데이터 용도에 맞추어 분할.



    CH.5 프로그래밍 언어
        1.1 프로그래밍 언어의 개요
        1. 개념
            -프로그램 : 컴퓨터를 이용한 문제 해결에서 컴퓨터에 내리는 명령어들의 집합.
            -프로그래밍 : 명령을 컴퓨터가 이해할 수 있도록 만드는 것.
            -프로그래밍 언어 : 컴퓨터가 이해할 수 있는 언어.

        2. 저급 언어와 고급 언어
            -저급 언어 : 하드웨어 지향의 컴퓨터 내부표현에 가까운 언어. 기계어, 어셈블리어가 해당.
            --기계어 = 0과 1
            --어셈블리어 = 간단한 기호로 최소화

            -고급 언어 : 일상 언어와 기호를 사용해 프로그램 작성. 이식성이 높다.
            C,자바, 파이ᄊᅠᆫ, 포트란, 코볼, 파스칼 등이 해당됨.


        3. 프로그래밍 언어의 발전
            -1세대 : 1940년대, 기계어 이용 프로그래밍. 어셈블리어 개발.
            -2세대 : 1950~1960년대 : 복잡한 프로그래밍을 작성하기 위해 고급 언어와 이를 기계어로 번역해주는 컴파일러가 개발됨.
            -3세대 : 1970년대 : 구조적 프로그래밍 기법의 파스칼과 C 개발됨. 고급언어 바탕의 유닉스와 ms-dos 개발 진행.
            -4세대 : 1980년대, 하드웨어의 가격이 내려가 개인용 컴퓨터가 대중화됨. 더 크고 복잡한 프로그램을 개발하기 위해 객체 지향 프로그래밍 기법이 등장함. 프로그래밍 개발 툴도 지원됨.

            -5세대 : 1990년대, GUI환경을 위한 여러 클래스의 라이브러리가 등장. 객체지향 언어의 장점이 주목받음. 자바, 파이썬 등이 개발됨. 웹 프로그래밍 또한 보편화되면서 html, js 등의 언어가 개발됨.
            -6세대 : 2000년대, 더 쉬운 개발을 위해 파워빌더, 델파이 등의 언어가 개발됨. C#, Go, 액션스크립트, 코틀린 등이 개발됨.


    4. 프로그래밍 언어별 특징.

    다음 시간에.


    

프로그래밍언어론 20220926

    함수를 쓰는 이유 -> 모든 X값에 대하여 하나의 Y값을 갖는다는 일반성을 갖고 있기 때문에.

    CH.3 프로그래밍 언어 설계 원칙

    프로그래밍 언어 설계 원칙
        -기본 원칙 
        --효율성 (목적 코드 실행, 번역, 구현, 프로그래밍의 시간 단축.)(구현 = 언어 번역기의 효율적 작성 가능 여부)
        --일반성 (특별한 경우 피하기 OR 관련된 개념들 묶기.)
        --직교성 (독립의 충분 조건. 독립성을 지닌 모듈을 의미한다. 서로 결합 분리가 자유.
        --획일성 (유사한 건 유사하게 보여야함. 그렇지 않은 건 아니게.)

        -기타 설계 원칙
        --간결성
        --안전성 : 정확성 : 언어가 예측된 대로 실행되어야 함.
        --표현력
        --기존 표기나 규칙과의 일관성
        --정확성
        --확장성
        --기계독립성
        --제약성, 부분성

    효율성
        -효율성의 기준에 따른 분류
        (위에 적음)

        -프로그램의 효율성은 프로그래밍의 단순성과 용이성 문제, 언어의 표현성과 추상화 매커니즘 , 신뢰도에 관계되어 있다. 이에 대해 이상적인 언어가 Prolog와 Lisp이다.

        소프트웨어의 효율성은 해독능력readability 와 유지보수능력maintainancapablity에 좌우된다.
