20221017_study

-정보보안

    정보보안은 교수님 출장으로 인해 시험 주간이 아닌 11월 1일에 시험 볼 예정.
    다음 주 강의는 동영상 강의로 대체.


    4장 키 분배와 사용자 인증

        -첫 번째 가상 절차


            데이터 전송 대부분 plain 평문으로.
            ID도 평문이지만 PW는 암호화. 보관도 암호화. 
            사용자의 입력이 저장된 것과 맞는 지 확인하기 위해서는 해싱을 통해 비교함.

            사용자 C의 패스워드=Pc 뿐만 아니라 클라이언트=C, 인증 서버=AS, 서버=V, 사용자C와 V의 식별자, 사용자 C의 네트워크 주소=ADc 등등의 헤더 정보 또한 비교한다. AS와 V가 공유하는 비밀 암호화 키=Kv 또한.


            ADc 사용 목적. 티켓을 요청한 워크스테이션에서만 티켓을 사용할 수 있게 하기 위해.


        여전히 비밀번호 평문 전송된다는 문제.
        ->비밀번호 인증 서버TGS 별도 추가.
        비밀번호를 매번 입력해야 한다는 문제.
        ->티켓을 재사용한다.


        가능한 공격 시나리오. 티켓을 가로채서 사용자가 로그오프할 때까지 대기.
        공격자는 사용자 주소와 공격 주소가 동일하도록 조작.
        티켓을 재사용하여 TGS를 속인다.


        대비책
        티켓 안에 타임스탬프 포함. 티켓 발행 시간과 유효 시간 표기.


        -개선된 가상적 절차.

            사용자 로그온 세션마다 한 번.
            서비스 유형마다 한 번.
            서비스 세션마다 한 번.
            TSi = 타임스탬프, Lifetime = 유효기간.


        -Kerberos 버전4 인증절차

            첫 번째 시나리오보다 안전.
            그래도 두 가지 문제점이 남아있음.
            1. 유효기간을 어떻게 적절하게 할 것인가?
            2. 서버 또한 자신을 사용자에게 인증해야함.

        이를 해결하기 위해 버전 4에서는 ‘개선된 가상적 절차’보다 더욱 개선된 방법을 쓴다.

            1 -> 너무 길면 재전송 공격이 가능함. 티켓 사용자=티켓 발행받은사람이 동일한 지확인해야함. AS와 TGS에게 C가 비밀키를 발급받아 TGS에게 인증받음.
            2 -> 인증 서비스 교환 = 티켓-발행 티켓 취득.

        Kerberos 공동체와 다중 Kerberi

            완전한 케르베로스 환경을 위한 추가 조건.

            1. 케르베로스 서버는 반드시 ID와 모든 사용자의 해시된 패스워드를 DB에 저장.
            =모든 사용자는 케르베로스 서버에 등록. 
            2. 다른 공동체 서버들과 비밀키를 공유.

-컴퓨터일반


    프로그래밍 문법 + 파이썬 공부 예정

    교재가 파이썬 활용임.


    파이썬 범용 라이브러리 아나콘다.
    선형대수 라이브러리 넘파이.
    인공지능신경망 end-to end 머신러닝 라이브러리 텐서플로우.
    예제 많은 머신러닝 라이브러리 파이토치. 
    데이터 조자과 분석을 위한 라이브러리 판다스.
    매트랩 비슷 매트플롯라이브러리
    .
    .
    .



    4장. 프로그래밍 문법

    4.1 변수 : 어떠한 값을 저장하는 메모리 공간. 다양한 형식이 존재.
        파이썬에서는 따로 선언하지 않아도 된다. = 동적 타이핑.
        생산성은 높아지지만 유지보수 시 정적보다 가독성이 떨어진다.

        변수 이름 규칙: 알파벳, 숫자, 밑줄로 선언 가능.
        유의미한 단어로 표기, 대소문자 구분함, 예약어는 사용 불가.


        입력문 input()
        출력문 output()


    4.2 자료형

    4.3 연산자

        -논리연산자
        -비교연산자

    4.4 조건문
        if 
        if elif
        if elif else 


    4.5, 반복문
        for : 범위 (=반복 횟수) 지정
        while 
        do

        break를 통해 조건을 주고 반복 종료 가능.
        continue를 통해 해당 반복 파트 중간에 다음 반복파트로 넘어갈 수 있다.


    5. 자료구조

    5.1 개요
        -자료 data = 처리 대상. 정리되어 있을수록 효과적임.
        이 자료를 효율적으로 표현하고 처리하고 정리하는 방법이 자료구조이다.
        -자료구조
            -단순 구조 : 정수 실수 문자 문자열 등.
            -선형 구조 : 배열, 연결 리스트. 스택, 큐
                (파이썬에는 리스트 없이 배열만)
        -자료구조와 알고리즘의 관계. 적합한 순서대로 수행하게 하는, 
            주어진 문제를 해결할 수 있는 명령어들의 집합.

    5.2 배열
    5.3 연결 리스트
    5.4 스택


    
-프로그래밍언어론


    CH.4 프로그래밍 언어의 구문과 구현 기법

        구문과 프로그램 신뢰성.

            구문. 언어의 신뢰성에 영향을 준다.

            현수(dangling) else 문제.

            우리가 쓰는 언어는 Context Free 문법.

            if (then) if (then) if else -> else절은 생략할 수 있도록 현재 문법에서는 만들어짐.
            A=B=C를 동시에 할 수 없으므로, 두가지만을 통해 구현함.

            이 else가 어디의 else인지 모르므로, 
            가장 가까운 then(조건)에 대한 else로 해석하도록 약속함. 
            중괄호를 통해 순서를 정한다.



 
        프로그래밍 언어 구현 기법.

            고급 언어는 기계어 또는 그와 상응하는 언어로 번역되어야만 한다.

            번역 기법/인터프리터 기법으로 분류,

            컴파일러, 어셈블러, 링커, 로더, 프리프로세서, (+인터프리터) 모두 번역기의 일종.
            링커=Linkage Editor 의 약자


            로더 = 기계어 프로그램을 실제 실행가능한 기계어로 번역.
            링커 : 로드 모듈 생성. 로드 모듈 = 어느정도 실행 가능한, 하나의 기계어 프로그램.
            어셈블러 : 원시언어가 어셈블러 언어, 목적언어가 준 기계어.
            컴파일러 : 원시언어가 고급언어, 목적언어가 저급언어(준 기계어/어셈블리언어)
            프리프로세서 = 원시,목적 언어 둘 다 고급언어임.

            인터프리터 기법 = 느림. 소프트웨어가 번역함
            (고급 언어 기계를 다른 기계에서 소프트웨어로 시뮬레이션 돌림.), 한줄씩.



        인터프리터와 번역 기법의 비교.

            번역기 = 입력 프로그램과 동일한 의미의 목적 언어 프로그램 생성.

            인터프리터 = 직접 입력 프로그램을 실행하는 방법으로 처리.

            비교 분석
                -순수 번역 기법
                -순수 시뮬레이션 기법
                -번역 효율적인 부분 존재
                -원시 코드의 시뮬레이션이 효율적인 부분 존재
                -순수 번역 기법이나 순수 시뮬레이션 기법은 실제로 거의 존재하지 않는다.


            번역 기법의 장단점.

                장점 : 실행 시간 효율 성 제공.
                단점 : 번역된 프로그램이 큰 기억장치 요구.

            인터프리터 기법의 장단점.
                장단점이 반대.
                사용자 적응성을 제공함.

            하이브리드 기법.
                프로그램을 실행시키기 쉬운 형태로 번역하여 번역된 프로그램을 시뮬레이션으로 실행함.
                현재 대부분의 인터프리터 언어는 이 방법을 따름.
                중간 형태 코드가 저급 언어라면 그냥 번역 기법으로 간주하기도 한다.


    CH5. 컴파일러 개요.

    *지금 16비트 이후의 PC는 모두 IBM 호환 컴퓨터.

    컴파일러의 일반적인 구성. 
        컴파일러는 특정 고급 언어로 적힌 프로그램을 타겟 컴퓨터에서 
        실행 가능한 코드로 번역하는 컴퓨터 프로그램이다.


    컴파일러 구조
        프론트엔드 : 언어 의존 영역 {Lexical 어휘 분석, Syntax 구문 분석, Semantics 의미 분석,
        Intermdiate code generation중간 코드 생성 으로 구성됨.]
        백엔드 : 기계 의존 영역

        둘을 나눠놓은 이유 : 하드웨어에 따라 기계어 코드가 달라질 수 있기 때문에.

        어휘분석 단계에서 1차적으로 표를 만드는 등 거의 1패스 단계가 이루어진다.

        어휘분석기 : 토큰 밸류와 토큰 넘버로 나누어 저장. 심볼테이블과 리터럴 테이블 등 테이블을 나누어 저장하게 된다.

        구문분석기=Syntax Analyzer=Parser : 구문확인과 트리 생성 역할. 

        중간 코드 생성기 : Semantics 의미 확인 + 중간 코드 생성. 
        -> 의미 분석기는 실제로 구현하는 것이 매우 어렵다. 아직까지 기계의 영역이 아님.


        백엔드.
            -Code Optimizer 코드 최적화 (optional phase)
            비효율적인 코드를 구분해내서 더 효율적인 코드로 바꾸어 준다.
            local/global 최적화로 나뉜다. 한번도 안쓰는 코드는 전역 최적화에 해당.

            -Target Code Generator 
            중간 코드로부터 machine instrction 기계명령어를 생성.

            -Error Recovery
            error가 다른 문장에 영향을 미치지 않도록 수정하는 것.
            에러 복구 : 에러가 발생하면 복구해주는 것.

            syntax에러는 쉬운 편.
            Runtime 에러가 제일 어렵다.