20221101_study

금일 강의 
정보보안 시험과 인공지능 자습



-정보보안 
    중간분량 정리


    1장~4장


    CH.1 개요
    1.1	컴퓨터 보안 개념
        정보보안 = 컴퓨터 보안 -> 네트워크 보안 -> 인터넷 보안
        -본 강의에서는 인터넷 보안에 대해 주로 다룬다.

    -보안 위배 예시 : 
        -노출 : 권한이 없는 사용자에게 열람
        -변경 : 권한이 없는 사용자가 수정
        -위장 : 권한 있는 사용자가 한 것처럼 송신
        -접속 차단 : 권한이 사라짐
        -부인 : 전송을 부정함

    -컴퓨터 보안의 개념 : 정보시스템의 자원인 가용성, 기밀성, 무결성 세가지를 지키려는 것.
         -핵심 보안 요구사항엔 위의 3가지에 인증성과 책임성이 추가된다.
    -추가개념
        -인증이란 사용자의 신원 혹은 정보의 내용을 인증하는 것.
        -책임이란 추적가능케 하는 것. 즉, 부인하지 못하게 한다.


    -OSI보안 구조 X.800
    -보안 공격	
    -보안 매커니즘
    -보안 서비스	
    -RFC2828에 정의된 위협과 공격
    -비슷하지만 다름. 위협은 잠재적인 것, 공격은 실재하는 시도.
    -보안 공격은 소극적과 적극적으로 나뉨
    -소극적은 갈취(엿보기), 트래픽 분석 등.
    -적극적은 그보다 위험한 것들. 직접적이고.

    -1장 1.6절부터 시작.
    -1.6 기본 보안 설계 원칙
        1. 경제적이어야함.
        2. Fail-safe 기본값. 특정대역 배제가 아니라 특정 대역 허가.
        3. 모든 액세스는 제어 매커니즘에 의하여 확인되어야함.
        4. 보안 매커니즘의 설계는 공개되어야함.
        5. 권한을 액세스 종류별로 분리해야함.
        6. 사용자에게 필요한 최소권한만을 부여해야함.
        7. 디자인이 서로 다른 사용자의 경우 공유 기능을 최소화해야함.
        8. 보안이 과해서 사용자가 불편하면 안됨. 심리적 수용 가능하게.
        9. 격리
        -공개 액세스 시스템은 주요 리소스에서 격리되어야함.
        -개별 사용자 간 프로세스와 파일은 서로 원하지 않는 이상 격리.
        -보안 매커니즘 또한 격리되어야함.
        10. 데이터 개체의 내부 구조는 하위 시스템만 액세스 가능하도록 캡슐화.
        11. 각 서비스별 다른 매커니즘을 제공하는 게 아니라 모듈화시켜 공용 설계 사용.
        12. 계층화. 시스템 운영자들의 접근 또한 계층화하여 실패에 대비함.
        13. 파격의 최소화. 보안 매커니즘이 사용자를 낯설게 해선 안됨.

    -1.7 공격 대상과 공격 트리 (attack surface&tree)
        -공격 대상은 네트워크, 소프트웨어, 인적으로 나뉨. 
        -공격 대상을 줄일 수록, 계층화를 심화할 수록 보안성이 높아짐.
        -공격트리란 보안취약점을 악용할 수 있는 계층적 데이터 구조.
        -공격 목표=루트노드, 루트노드에 접근하는 세부 단계인 서브노드들로 나뉜다.
        -잎leaf 노드=공격을 시작하는 다른 노드.
        -leaf노드가 아닌 노드는 모두 AND/OR 노드이다.

    1.8 네트워크 보안 모델.
        -보안 모델은 모두 암호화된 메세지와 암호화 키 두가지 속성을 가진다.
        -안전한 전송을 위해서는, 암호화 키를 두 통신 주체에게 전달해줄 신뢰가능한 제 3자가 필요하다.
    -보안 서비스 설계 4 기본 Task
        1. 보안 관련 변환을 위한 알고리즘 설계
        2. 이 알고리즘에서 사용될 비밀 정보 생성
        3. 비밀 정보 공유와 배분 방법 개발
        4. 양쪽에서 사용할 구체적 프로토콜 선정
    -영단어 취약점 = vulnerability

    1.9 표준
        -NIST
        -ISOC
        -IETF, IAB, RFC

            -전수공격
                :모든 키 대입
                확률적으로 절반쯤 대입했을 때 정답을 맞춘다.
                56비트(7글자)까지 요즘 기술로 금새 뚫린다.


            -대칭블록암호 설계요소
                -블록길이 : 주로 64비트. 요즘은 더 높음.
                -키길이 : 보편적 128비트. 길이가 길수록 보안업, 성능다운.
                -라운드수 : 전형적 16라운드
                -서브키 생성 알고리즘 : 복잡할수록 암호해독이 어려워진다.
                -라운드 함수 : 복잡할수록 암호해독이 어려워진다.

            -대칭블록암호 설계시 고려 사항
                -빠른 소프트웨어 암호화 복호화
                : 암호화에 오래걸리면 사용성 저하
                -용이한 해독
                : 알고리즘을 간결하고 명확하게 설명할 수 있어야 한다. 
                취약성 분석이 쉬워지므로 개선 또한 쉬워진다.

            DES=56비트
            AES= 128비트, 256비트, 192비트, 256비트
            3중DES=168비트 (56*3)

            -DES
                -알고리즘은 DEA라고 부른다. 암호화 방식(포준)이름이 DES.

                평문 64비트
                키 56 비트
                구조 FEISTEL 네트워크 변형
                라운드 16
                서브키 원래키로부터 16개 48비트 서브키 생성하여 각 라운드에서 사용


            -DES의 강도
                -키길이의 취약성. 
                56비트 키이므로, 마이크로 초 당 천의 암호화 수행 시 
                매우 오랜 시간이 걸렸었지만 요즘은 컴퓨터가 더 빨라져서 약해짐.

            -DES 크래커 머신 1938년 by EEF
                -25만불 이하로 만들어진 특별기계.
                -공격이 3일 이내로 성공함.
                -그래서 더 이상 쓰지 않음.
                -최근 멀티코어 컴퓨터는 초당 10^9의 키조합 가능.
                슈퍼컴 기준 10^13번 가능. 2012년 자료로.

            -AES 암호화의 경우 가장 낮은 128비트마저 양자컴퓨터로도 해독에 매우 오랜 시간이 걸린다.


            -3중 DES
                :3개의 키를 사용해 dES알고리즘 3번 수행.

                암호-복호-암호 순서로 수행.

                암호화 
                C= E(K3D(K2E(K1P)))

                C=암호문
                P=평문
                E[K,X] 키 K를 이용해 X를 암호화
                D[K,Y] 키 K를 이용해 Y를 복호화

                사용한 이유 -> 기존 DES와의 호환성 때문에.

                3개의 다른 키를 사용하여 168비트의 유효성 길이.
                1개의 같은 키를 이용할 경우 DES와 동일 알고리즘이 된다. DES암호화복호화 = 1 이므로.

            -3DES이 주요 약점
                -3DES는 느리다.
                -64비트 블록을 사용하기에 블록 사이즈가 커져야한다.
                -따라서 장기적 표준으로 DES는 부적합하다.
                -NIST는 1997년에 3DES와 같거나 더 나은 강력한 보안성을 갖으면서 
                월등히 개선된 효율적인 새로운 AES (Advanced Encryption Standrd)를 공모함.

                최종선정 = 2001년 11월 최종 표준.
                레인달이 최종 표준으로 선정.
                개발자 : 벨기에 암호학자 요안 대믄, 빈슨트 레이믄.



        -2장 대칭 암호와 메시지 기밀성.

            -대칭 암호 원리
            5가지 요소 평문(원문, 데이터), 암호화 알고리즘, 비밀 키, 암호문, 복호화 알고리즘


            -Feistel 암호 구조
                DES의 암호 구조임.
                모든 대칭 블록 암호에서 사용된다. 
                여러개의 라운드로 구성되는데, 라운드에서 수행되는 대칭 블록 암호 구현은 
                ‘블록 길이, 키 길이, 라운드 수, 서브키 생성 알고리즘, 라운드 함수, 에 달라진다.  
                설계 시 고려 사항으로는 암호화/복호화의 속도, 해독의 용이성(알고리즘의 간결성)에 있다.

            -보편적으로 쓰이는 대칭 암호 알고리즘 = 블록 암호( block cipher)
                :고정된 크기의 블록 평문 입력, 동일 크기의 블록 암호문 생성.
                DES,3DES, AES가 대표적. 


            -AES 암호화

                128, 192, 256 비트

                Feistel 구조가 아님. 페이스텔은 라운드당 반쪽을 다른 반쪽을 수정하는 데에 사용하고 그 뒤에 서로 교환하지만, AES는 라운드 당 블록 전체를 병렬 처리한다.

                암호가 128비트 내용이 128, 192, 256비트.

                step 연산 네가지 사용.
                subBytes, MixColumns, ShiftRows, AddRoundKey
                행이동 ShitRows 만 치환, 나머지 3번은 교환.




            -난수의 용도
                네트워크 암호 알고리즘들에서 사용. 

            -난수의 특성. 
                무작위성. (균등분포, 독립성), 예측 불가능성. 


            -TRNG, PRNG, PRF

                의사 난수 = 알고리즘에 의해 생성된 무작위성을 가진 수열.

                진성 난수 생성기 TRNG : 입력 값으로 엔트로피 소스 사용.

                의사 난수 생성기 PRNG : 무한비트열 생성

                의사 난수 함수 PRF : 고정된 길이의 의사 난수 비트열 생성기

            -스트림암호
            블록 암호 Cipher : 입력 블록에 대응되는 출력블록을 만든다. 
                입력되는 하나의 블록을 한번에 한 블록씩 처리한다.

            -스트림 암호 Cipher : 한 번에 평문 한 바이트씩 암호화. 
                입력되는 요소를 지속적으로 처리하여 지속적으로 한번에 한 요소씩 처리한다


            -스트림 암호 설계시 주의 사항.
                1. 암호화열의 주기가 길어야함. 
                의사난수는 반복적으로 나타나는 비트스트림을 생성하기에, 
                패턴의 주기가 길어져야 해독이 그나마 어려워짐.

                2. 키스트림은 가능한 한 진성랜덤넘버 특성을 근사해야한다.
                (0,1 개수가 되도록 동일. 모든 가능한 바이트 값이 거의 동일한 횟수에 준하게 나타나야함.)

                3. 의사난수 생성기의 출력은 입력키 값에 의해 조절되므로, 
                전수공격을 차단하기 위해 최소 키를 128비트로 잡음.

            잘 설계된 의사난수 생성기로 구현된 스트림 암호화는 동일 키 길이를 사용하는 블록 암호화만큼 안전하다.

            -스트림 암호화의 장점
                :블록 암호화보다 더 빠르고 훨씬 적은 코드를 쓴다. 가장 많이 쓰이는 RC4는 고작 몇줄의 코드만 사용한다.



            RC4 알고리즘. 이해 필요. 이해시간 10분 주심.



        -2.5 암호 블록 운용 모드

            DES와 3DES는 블록 길이 b=64비트이다.
            AES b=128비트.
            padding. 원문 비트수 끝단이 부족할 시 0으로 채워넣는 것.


            암호 블록 운용 모드. 5가지. DES나 AES를 포함하여 어ᄄᅠᆫ 대칭 블록 암호에도 적용할 수 있다.
                -전자 코드북 모드 ECB : 가장 간단한 응용 모드. 각 블록을 동일한 키로 암호화.
                -암호 블록 체인 모드 CBC : 현재와 직전의 코드블록을 XOR 한 결과를 알고리즘의 입력으로 사용. 첫 번째 암호 블록은 초기화 벡터와 첫 번째 블록을 XOR.
                -암호 피드백 모드 CFB : 암호문 길이 = 평문 길이여야 좋다.
                -출력 피드백 모드
                -카운터 모드 CTR : 평문 블록과 동일한 크기의 카운터를 이용하되, 카운터 값이 반 듯 ㅣ암호화 될 각각의 평문 블록 별로 다 달라야함.
                    -장점 : 하드웨어 효율성(병렬처리)
                        소프트웨어효율성(효율적 프로세서 활용)
                        사전처리(카운터를 암호화하여 사전에 준비해서, XOR만 수행하면 됨)
                        랜덤접근(블록이 한 개만 있어도 복호화 가능)
                        입증 가능한 보안성 (다른 모드만큼 안전)
                        단순성(암호화와 복호화 알고리즘이 동일함)
                    -응용분야 : ATM(비동기 전송 모드) 네트워크 보안, IP 시큐리티



        3장 공개 키 암호와 메시지 인증

        3.1 메시지 인증 방법.

        암호 사용 시 passive 공격(도청 등) 방어 가능, 그러나 active는 다른 방법이 필요하다.
        소스(근원지) 인증과 메시지(본문) 인증, 메시지 인증에는 이 두가지 요소가 필요하다.

        관용 암호를 이용한 인증
            -송신자 수신자 둘이 동일한 키를 가지고 있다고 가정
            -오직 진짜 송신자만이 수신자에게 보내는 메시지를 성공적 암호화 가능.
            -메시지 변경 탐지
                -오류 감지 코드 및 순서 번호 존재 시 변경 여부와 순서 확인 가능.
                -타임스태프 : 딜레이(지연) 없는 전달 확인.
            -대칭암호만 가지고서는 데이터 인증에 부적합하다.
                -ECB 모드의 암호화에서는 공격자가 암호문의 블록을 뒤섞으면 내용도 뒤바뀐다.


        메시지 암호화 없이 메시지 인증
            -암호에 의존하지 않고 메시지 인증 방법
                -암호화 안하고 인증 꼬리표tag 붙여 보내기.
                -대신 기밀성은 보장하지 않는다.

        메시지 암호 없는 메시지 인증이 적합할 때
            -브로드 캐스팅 : 네트워크경고
            -메시지 복호화 시간이 부족할 때(ex:테스팅)
            -컴퓨터 프로그램은 평문인 채로 인증하는 게 더 편리하다.


        메시지 인증 코드 MAC
            :메시지에 붙여지는 작은 데이터 블록을 생성하기 위해 비밀키를 이용하는 방법.

        MAC 계산법 : p.76

        MAC 효과 :
            -수신자는 메시지가 변경되지 않았다고 확신.
            -수신자는 송신자가 소스임을 확신.
            -메시지 순서번호를 사용 시 순서도 확신.

            여러 알고리즘이 사용가능하나, NIST 규격 뭐시기에서는 DES사용을 권장한다.
            암호화된 메시지의 끝단 일부분MAC만을 비교 대상으로 사용한다?
            암호화와 다른 점은, 인증 알고리즘으로는 복호화에서의 역산이 불가능하다는 것이다.


        일방향 해시 함수
            : 메시지 인증 코드처럼 임의 크기의 메시지M을 받아들여 일정한 크기의 메시지 다이제스트 H(M)을 출력하는 함수.

            -해시 = H(M)
                -H : 해시함수, M=메시지

        일방향 해시 함수를 이용한 메시지 인증 방법
            -관용 암호 사용 방법
            -공개키 암호 사용 방법
            -비밀 값 사용 방법


        3.1 일방향 해시함수(one-way hash function) 
        : 메시지 인증 코드처럼 임의크기의 메시지 M을 입력을 받아들여 
        일정한 크기의 메시지 다이제스트 H(M)을 출력하는 함수
            해시=H(M)
            H: 해시함수
            M: 메시지
            MAC과는 달리 비밀키가 필요없음

        3.2 Secure Hash Funcuntions

            -해시 함수의 용도
                :메시지 인증, 디지털 서명
            -파일, 메시지, 데이터 블록에 대한 지문=fingerprint를 생성

            SHA = 안전한 해시 알고리즘


            -해시 함수의 요건

                1. 임의(=아무) 크기의 데이터 블록에 적용될 수 있어야함.
                2. 고정된 길이의 출력을 가져야 함.
                3. 계산 용이성과 구현 가능성을 갖춰야함.
                4. 일방향(단방향) 성질을 갖춰야함. y를 통해 x값을 계산할 수 있어서는 안된다. 
                (= preimage 저항성. 해시값으로 원문을 알아낼 수 없어야 한다.)
                5. 약한 충돌 저항성 = 2차 preimage 저항성. 동일한 해시값을 임의로 만드는 것이 불가능해야 한다.
                6. 강한 충돌 저항성 : f(x1)=f(x2)인 두 입력값 x1, x2를 찾을 수 있는 일을 방지하는 것.



            단순 해시 함수 
                -비트별 XOR

            단순 해시 함수 문제 해결법
                반전 후 대칭 연산? 차후 다시 봐야함.



            SHA 안전 해시 함수

                :최근 가장 널리 쓰임.

                SHA-1은 md4에 기초. 2005년에 NIST 승인 취소됨.

                SHA-2는 1과 하부구조가 동일하다.
                    SHA-256, SHA384, SHA-512. 동일 구조에 비트수만 늘어남.

                SHA-3 
                    : SHA-224. 오히려 비트수가 줄어들었다.


                

                처리단계 5단게.

                    1. 패딩 비트 붙이기 (1100비트의 경우 : 2^단위에서 빼야하는데, 128bit 패딩비트를 붙이지 못하므로, 2048 비트 중 1100이 메시지, 910이 패딩, 128이 해시가 된다.
                    2048 기준으로 
                    2. 길이 붙이기 (패딩하기 전의 길이를 원문에 붙인다.)
                    3. MD 버퍼 초기화 (버퍼를 8개의 64비트 레지스터로 나타낸다. 해시 함수의 중간값과 최종값을 저장하기 위해 .
                    4. SHA-512를 사용하는 메시지 다이제스트 생성	과제 : 학번 등으로 메시지 다이제스트 만들어서 제출하기.
                    5. 추가 공부 필요.



            3.3 메시지 인증 코드

                HMAC = Hashed MAC

                    SHA-1:암호적 해시코드를 이용한 MAC방법.
                    기존 해시 알고리즘에 키를 삽입하려는 제안이 많아짐.
                    그 중 HASH가 가장 관심이 큼.

                    -HMAC : IP 보안 용 필수 MAC
                    -TLS 프로토콜에서 사용.
                    -SET(시큐어 일렉트로닉 트랜잭션) 프로토콜에서도 사용.

                    -HMAC의 장점 
                        -빠른 속도. DES에 비해 소프트웨어적으로 빠름
                        -암호적 해시 라이브러리 코드를 쉽게 구할 수 있다.

                    -HMAC 설계 목표
                        -RFC 2014
                        -수정하지 않고 쓸 수 있는 해시 코드.
                        -필요 시 기존 해시 함수를 쉽게 교체 가능하도록.
                        -해시 함수의 원래 성능을 최대한 보전, 빠르게.
                        -키를 쉽게 다루기.

                        처음 2개 =HMAC에서는 해시 함수를 블랙박스로 간주. 따라서 해시 함수 구현을 모듈로 사용.
                    
                    -HMAC 알고리즘 p.89~90
                        H=해시 함수. SHA-1 등.
                        M=HMAC의 입력 메시지.(해시함수에 필요한 패딩까지 포함)
                        Yi=M의 i번째 블록. 0<=i<=(L-1)
                        L=M의 블록 수
                        b=블록의 비트 수
                        b=내장된 해시 함수에 의해 생성된 해시 코드의 길이.
                        K=비밀키. 키의 길이가 b보다 길 때 n-비트 키를 생성하는 해시함수에 입력으로 사용됨.
                        K+ = K의 왼쪽에 0붙여서 b길이 맞춘 것.
                        ipad = 16진수 36을 b/8번 반복한 2진 수열
                        opad = 16진수 5C를 b/8번 반복한 2진 수열

                블록 암호 기반 MAC

                : 블록 암호를 이용하여 MAC을 생성하는 방법.

                암호-기반 메시지 인증 코드 CMAC
                암호블록체인 카운터-메시지 인증코드 CCM


                -CMAC
                    운용모드 AES 3DES

                    메시지 n개 블록.
                    k-비트 암호키와 n-비트 키.





                공개키 암호 구조

                    1976년 디피에와 헬만이 제안.
                    수학적 함수에 근거.
                    서로 다른 두 키를 이용하는 비대칭 방식.
                    기밀성, 키 분배, 인증에서 뛰어난 성능.


                    공개키 암호 핵심 요소

                        평문
                        암호 알고리즘
                        공개키와 개인키
                        암호문
                        복호 알고리즘

                    공개키 암호의 응용

                        암호화/복호화
                        :수신자의 공개키로 메시지 암호화.
                        디지털 서명
                        :송신자 자신의 개인키로 메시지 암호화(서명)
                        키 교환.
                        :세션 키를 교환(공유)한다.

                        -> 짧은 메시지에 적합.


                    공개키 암호 요건p/98

                    RSA 공개키 암호 알고리즘
                        제작자 : 론 리베스트 애디 샴미르 렌 아델만
                        1978년 출판

                        암호화와 복호화 p.99

                

                    RSA

                        송수신자 모두 n과  e를 알고 있어야 하고, 오직 수신자만이 d 값을 알고 있어야 함.

                        공개키 PU=[e,n]
                        개인키 PR=[d,n]

                    RSA 공개키 암호 요구 조건 p.100




                    RSA 알고리즘 101p 외우기. 키 생성 암호화 복호화. 중요 중요 중요 중요 중요


                    보안 관점

                    -수학적 공격 : 공통적으로 인수분해 방식 사용.
                    -방어법 : 키를 길게 함. 처리속도가 느려진다는 단점.
                    2016년 기준 권장길이는 3072비트.

                    타이밍 공격. 복호화 알고리즘의 복호화 시간을 측정해서 키 길이를 예측. 시간이 드러나지 않게 랜덤 지체 방법 사용.
                    선택 암호문 공격. 암호 해독에 필요한 정보가 드러날 수 있는 데이터 블록을 선택해서 rSA 알고리즘의 특성을 악용.
                    목표의 개인키를 사용해서 처리할 때 드러남. 평문에 패딩 추가하여 방지 가능.





                RSA 알고리즘을 깨는 방법.

                    전수공격. 비트 수가 클 수록 안전.

                    n을 두개의 소인수로 인수분해.


                과제 RSA 알고리즘 깃허브 인코딩 디코딩 실습 캡쳐하기.

                디피에 헬멘 =/ RSA.
                    이산 대수 문제를 푸는 것이 어렵다는 것을 이용.


        -Diffie-Hellman 키교환

            두 사용자가 비밀키(대칭키)를 안전하게 교환해서 메시지를 암호화하려는 목적.

            이산대수 문제를 푸는 것이 어렵다는 데 근거함.


            이산대수 문제란? 

                소수 p의 원시근 primitive root :
                자신의 거듭제곱을 보일 때 1부터 p-1의 정수를 모두 생성가능한 수.

                어떤 수 a가 소수 p의 한 원시근이라면, 다음



            -이산대수 문제는
            b=a^i*mod p (0<=i<p-1)

            여기에서 지수 I를 밑수 a를 갖는 b를 이산대수 혹은 지수라고 한다.
            이 수를 I=d*log(a,p)(b)라고 나타낸다.

            -이산 로그는 몇가지 특별한 경우에 빠르게 계산 가능하지만,
            일반적으로 효율적으로 빠르게 계산하는 방법은 알려지지 않았다.


            디피에-헬먼 알고리즘은 이를 이용하여,
            양측 A와 B에게는 하나의 소수 q와 q의 한 원시근 a만 주어져 있을 때,

            A가 한 랜던넘버 Xa < q를 택하고, Ya=a^XB*mod q 
            를 계산.

            B는...

            양측은 X를 개인값으로 보관하고 Y를 상대방이 사용할 수 있도록 공개한다.


            상대방이 준 Y값과 자신의 X값을 이용해서 공통의 키를 공유한다.

            공격자에게 주어지는 정보

                q,a, YA,YB

                알 수 없는 정보 XA, YB

                A와 B의 비밀값을 알려면 공격자는 이산대수문제를 풀어야한다.




        3.6 디지털 서명

            -NIST이 정의. 데이터를 암호학적으로 변환한 결과. 적절하게 구현할 시 출처인증, 데이터무결성, 서명인 부인 봉쇄를 검증하는 매커니즘에 사용된다.

            인증자를 통해 메시지 무결성을 보증할 수 없다. 인증자 변경 없이 문서만 변경할 수 없게 한다. 대신 기밀성은 보장할 수 없다.

            -디지털서명알고리즘 DSA
                -???:NIST 원래의 공식. 이산대수문제를 풀어야함. 
                -RSADSA
                -타원곡선 DSA

            RSS-PSA 곡선생성 그림 -> 이런 그림이 있다는 정도만 알아둘 것.



        제4장 네트워크보안응용

        4.1 대칭 암호를 이용한 대칭키 분배

            4가지 방법
                -1. A가 키 선택해서 B에게 직접 전달.
                -2. 제 3자가 키를 선택한 뒤 A와 B에게 직접 전달.

            위 두 개는 매뉴얼 전달 방식.

                -3. A와 B의 공유키로 한 사람이 새 키를 작성하고 공유키로 암호화하여 상대방에게 전송.

                -4. 제 3자 C와 A,B가 암호화된 연결을 가지고 있다면 C가 A와 B에게 키를 전달.


            4번째 방법에서는 세션키와 영구키를 사용. 영구키는 세션키의 분배에 필요하며 재사용함. 키 분배 센터 KDC에서 활용한다.



            4.2 Kerberos
            프로토콜. MIT에서 개발.
            제 3자, 중개자이다. https에서 차용하였다.


        4장 키 분배와 사용자 인증

            -첫 번째 가상 절차


                데이터 전송 대부분 plain 평문으로.
                ID도 평문이지만 PW는 암호화. 보관도 암호화. 
                사용자의 입력이 저장된 것과 맞는 지 확인하기 위해서는 해싱을 통해 비교함.

                사용자 C의 패스워드=Pc 뿐만 아니라 클라이언트=C, 인증 서버=AS, 서버=V, 사용자C와 V의 식별자, 사용자 C의 네트워크 주소=ADc 등등의 헤더 정보 또한 비교한다. AS와 V가 공유하는 비밀 암호화 키=Kv 또한.


                ADc 사용 목적. 티켓을 요청한 워크스테이션에서만 티켓을 사용할 수 있게 하기 위해.


            여전히 비밀번호 평문 전송된다는 문제.
            ->비밀번호 인증 서버TGS 별도 추가.
            비밀번호를 매번 입력해야 한다는 문제.
            ->티켓을 재사용한다.


            가능한 공격 시나리오. 티켓을 가로채서 사용자가 로그오프할 때까지 대기.
            공격자는 사용자 주소와 공격 주소가 동일하도록 조작.
            티켓을 재사용하여 TGS를 속인다.


            대비책
            티켓 안에 타임스탬프 포함. 티켓 발행 시간과 유효 시간 표기.


            -개선된 가상적 절차.

                사용자 로그온 세션마다 한 번.
                서비스 유형마다 한 번.
                서비스 세션마다 한 번.
                TSi = 타임스탬프, Lifetime = 유효기간.


            -Kerberos 버전4 인증절차

                첫 번째 시나리오보다 안전.
                그래도 두 가지 문제점이 남아있음.
                1. 유효기간을 어떻게 적절하게 할 것인가?
                2. 서버 또한 자신을 사용자에게 인증해야함.

            이를 해결하기 위해 버전 4에서는 ‘개선된 가상적 절차’보다 더욱 개선된 방법을 쓴다.

                1 -> 너무 길면 재전송 공격이 가능함. 티켓 사용자=티켓 발행받은사람이 동일한 지확인해야함. AS와 TGS에게 C가 비밀키를 발급받아 TGS에게 인증받음.
                2 -> 인증 서비스 교환 = 티켓-발행 티켓 취득.

            Kerberos 공동체와 다중 Kerberi

                완전한 케르베로스 환경을 위한 추가 조건.

                1. 케르베로스 서버는 반드시 ID와 모든 사용자의 해시된 패스워드를 DB에 저장.
                =모든 사용자는 케르베로스 서버에 등록. 
                2. 다른 공동체 서버들과 비밀키를 공유.


        -Kerberos 버전 5.

        버전 4와의 차이점?
        버전4의 결함.
        환경적/기술적 결함 개선


        -환경적 결함
            :암호화 시스템 의존성. DES만 사용했다. -> 모든 종류 암호화 사용 가능하게
            인터넷 프로토콜 의존성. IP 주소만 사용했다. -> 모든 유형의 네트워크 주소 사용 가능하게.
            메시지 바이트 순서. Big endian & Little endian -> ASN.1 & BER
            티켓 유효기간. 대략 21시간 -> 정확한 시작시간, 만료시간.
            인증전달 -> 버전5에서는 가능해짐.
            공동체간 인증. N^2수준의 필요 관계 -> 더 적은 숫자의 관계가 필요한 방법 지원.


        -기술적 결함
            :이중 암호화. 표 4.1에서 암호화를 두 번에 걸쳐 하지만, 실제로 두 번째 암호는 불필요.
            PCBC암호화 사용. 무결성 검사 목적의 DES 비표준 모드. -> 버전 5에서 표준 CBC 모드를 사용하도록 변경.
            세션키. 지속사용 ->재전송 공격 위협 존재. C/S가 서브 세션키를 협상/사용하도록 변경.
            패스워드 공격. 버전5도 공격에 취약함. 그래서 preauthentication을 도입하여 공격 난이도를 높임.



        버전5 인증 절차.

            1. 인증서비스 교환
            2. 티켓 발행 서비스 교환
            3. 클라이언트- ? 교환

            1. 인증 서비스 교환
                -공동체 
                -선택사항
                -시간
                -비표 : 메시지(2)에서 반복 사용되는 랜덤넘버. 응답이 재전송된 것이 아님을 확신하기 위한 용도. Nonce.

                - 인증-발행 티켓 취득.


            2. 티켓-승인 서비스 교환
                - 서비스-발행 티켓 취득.



            3. 클라이언트/서버 인증 교호나.

                -서브키:특정 응용 세션 보호를 위해 사용할 암호화 키. 클라이언트가 선택함. 이 필드가 생략되면 티켓의 세션키 Kc,v를 이용한다.
                -순서번호 : 선택사항 필드, 시작 순서번호. 해당 세션에서 서버는 클라이언트로 보내는 메시지에 이 번호를 사용한다. 재전송 감지를 위해 



        4.3 비대칭 암호화를 이용한 키 분배

            공개키 암호의 용도
                -공개키 분배
                -대칭 비밀키 분배


            공개키 인증서
                ㄴ공개키와 키 소유자의 사용자 ID로 구성. 이를 신뢰할 만한 제3자가 서명.
                제 3자 =정부기관, 금융기관 등 신뢰하는 인증기관 CA
                -안전한 공개키 전달.


            공개키 인증서 활용 방법
                1.메시지 준비하기.
                2. 일회용 세션키를 이용하는 관용 암호기법으로 메시지를 암호화.
                3. 엘리스의 공개키를 이용해서 그 세션키를 암호화.
                4. 암호화된 세션키를 메시지에 첨부해서 엘리스에게 보낸다.
                엘리스만이 세션키를 해독할 수 있으므로 원본 메시지를 복구할 수 있음.
                밥이 앨리스의 공개 키 인증서를 통해 엘리스의 공개키를 얻은 경우 밥은 이것이 유효한 키임을 확실함.


        4.4 X.509 인증서
            ITU-T 권고안. 디렉터리 서비스를 정의하는 X.500 tlflwmdml gks qnqns.
            디렉터리? 사용자 정보 데이터베이스를 관리하는 하나의 서버 또는 분산 서버 집단.
            X.509는 인증 서비스의 구조와 프로토콜을 규정.
            공개키 인증서의 저장소로 이용한다.


        4.5 공개키 기반 구조. PKI.
            RFC 4949에서 정의함.


            인증서
            CA<<A>>
            ->A에 대한 인증서인데 CA에서 발행함.


            사용자 인증서 얻기.
            CA가 발행한 사용자 인증서 특성.
            공개키를 얻을 수 있는 사용자는 누구든지 특정 사용자의 인증된 공개키를 확인할 수 있다.

            인증기관을 제외한



            인증서 체인.


            인증서 취소.
            각 인증서에는 유효기간이 포함 -> 만료 전에 새 인증서를 발행해야함.
            취소해야 하는 경우
            1 사용자 개인키가 노출, 훼손,
            2. CA가 사용자를 인증해줄 수 없는 경우.
            3. 



            X.509 버전3
            버전2에 비해 확장을 많이 함.



        4.6 통합신원관리
        Federated identity management
            -상대적으로 새로운 개념.
            -다수의 기업과 많은 응용프로그램을 관리하는 일반적 신원관리 시스템.
            -수천 또는 수백만명의 사용자를 지원하는 관리시스템이다.


            신원관리
                -접근관리권한
                -SSO Single Sign-On : 한번의 로그인을 통해 여러 서비스에 모두 접속할 수 있음. 구글 로그인을 통해 지메일, 구글독스, 구글 드라이브 서비스에 모두 접속할 수 있는 것처럼.


            신원관리 주요 요소
                -인증
                -허가
                -계정-프로비져닝
                -작업절차 자동화
                -관리위임
                -패스워드 동기화
                -셀프서비스 패스워드 리셋
                -통합


            표준
                :조직에서는 협업 파트너가 처리할 수 있는 일종의 보안 티켓을 사용자에게 발행.
                신원 통합 표준. 티켓 내용과 형식을 정의하고 티켓 교환용 프로토콜을 제공하고, 